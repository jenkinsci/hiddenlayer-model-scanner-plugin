/*
 * HiddenLayer ModelScan V2
 * HiddenLayer ModelScan API for scanning of models
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.net.URI;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.StringJoiner;

/**
 * A component, such as a plug-in or the driver, of the analysis tool that was run.
 */
@JsonPropertyOrder({
    ToolComponent.JSON_PROPERTY_GUID,
    ToolComponent.JSON_PROPERTY_NAME,
    ToolComponent.JSON_PROPERTY_ORGANIZATION,
    ToolComponent.JSON_PROPERTY_PRODUCT,
    ToolComponent.JSON_PROPERTY_PRODUCT_SUITE,
    ToolComponent.JSON_PROPERTY_SHORT_DESCRIPTION,
    ToolComponent.JSON_PROPERTY_FULL_DESCRIPTION,
    ToolComponent.JSON_PROPERTY_FULL_NAME,
    ToolComponent.JSON_PROPERTY_VERSION,
    ToolComponent.JSON_PROPERTY_SEMANTIC_VERSION,
    ToolComponent.JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION,
    ToolComponent.JSON_PROPERTY_RELEASE_DATE_UTC,
    ToolComponent.JSON_PROPERTY_DOWNLOAD_URI,
    ToolComponent.JSON_PROPERTY_INFORMATION_URI,
    ToolComponent.JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS,
    ToolComponent.JSON_PROPERTY_NOTIFICATIONS,
    ToolComponent.JSON_PROPERTY_RULES,
    ToolComponent.JSON_PROPERTY_TAXA,
    ToolComponent.JSON_PROPERTY_LOCATIONS,
    ToolComponent.JSON_PROPERTY_LANGUAGE,
    ToolComponent.JSON_PROPERTY_CONTENTS,
    ToolComponent.JSON_PROPERTY_IS_COMPREHENSIVE,
    ToolComponent.JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION,
    ToolComponent.JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION,
    ToolComponent.JSON_PROPERTY_ASSOCIATED_COMPONENT,
    ToolComponent.JSON_PROPERTY_TRANSLATION_METADATA,
    ToolComponent.JSON_PROPERTY_SUPPORTED_TAXONOMIES,
    ToolComponent.JSON_PROPERTY_PROPERTIES
})
@javax.annotation.Generated(
        value = "org.openapitools.codegen.languages.JavaClientCodegen",
        date = "2024-12-03T15:49:05.899737Z[GMT]",
        comments = "Generator version: 7.6.0")
public class ToolComponent {
    public static final String JSON_PROPERTY_GUID = "guid";
    private String guid;

    public static final String JSON_PROPERTY_NAME = "name";
    private String name;

    public static final String JSON_PROPERTY_ORGANIZATION = "organization";
    private String organization;

    public static final String JSON_PROPERTY_PRODUCT = "product";
    private String product;

    public static final String JSON_PROPERTY_PRODUCT_SUITE = "productSuite";
    private String productSuite;

    public static final String JSON_PROPERTY_SHORT_DESCRIPTION = "shortDescription";
    private MultiformatMessageString shortDescription;

    public static final String JSON_PROPERTY_FULL_DESCRIPTION = "fullDescription";
    private MultiformatMessageString fullDescription;

    public static final String JSON_PROPERTY_FULL_NAME = "fullName";
    private String fullName;

    public static final String JSON_PROPERTY_VERSION = "version";
    private String version;

    public static final String JSON_PROPERTY_SEMANTIC_VERSION = "semanticVersion";
    private String semanticVersion;

    public static final String JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION = "dottedQuadFileVersion";
    private String dottedQuadFileVersion;

    public static final String JSON_PROPERTY_RELEASE_DATE_UTC = "releaseDateUtc";
    private String releaseDateUtc;

    public static final String JSON_PROPERTY_DOWNLOAD_URI = "downloadUri";
    private URI downloadUri;

    public static final String JSON_PROPERTY_INFORMATION_URI = "informationUri";
    private URI informationUri;

    public static final String JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS = "globalMessageStrings";
    private Map<String, MultiformatMessageString> globalMessageStrings = new HashMap<>();

    public static final String JSON_PROPERTY_NOTIFICATIONS = "notifications";
    private Set<ReportingDescriptor> notifications = new LinkedHashSet<>();

    public static final String JSON_PROPERTY_RULES = "rules";
    private Set<ReportingDescriptor> rules = new LinkedHashSet<>();

    public static final String JSON_PROPERTY_TAXA = "taxa";
    private Set<ReportingDescriptor> taxa = new LinkedHashSet<>();

    public static final String JSON_PROPERTY_LOCATIONS = "locations";
    private List<ArtifactLocation> locations = new ArrayList<>();

    public static final String JSON_PROPERTY_LANGUAGE = "language";
    private String language = "en-US";

    /**
     * Gets or Sets contents
     */
    public enum ContentsEnum {
        LOCALIZEDDATA("localizedData"),

        NONLOCALIZEDDATA("nonLocalizedData");

        private String value;

        ContentsEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static ContentsEnum fromValue(String value) {
            for (ContentsEnum b : ContentsEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }
    }

    public static final String JSON_PROPERTY_CONTENTS = "contents";
    private Set<ContentsEnum> contents =
            new LinkedHashSet<>(Arrays.asList(ContentsEnum.LOCALIZEDDATA, ContentsEnum.NONLOCALIZEDDATA));

    public static final String JSON_PROPERTY_IS_COMPREHENSIVE = "isComprehensive";
    private Boolean isComprehensive = false;

    public static final String JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION = "localizedDataSemanticVersion";
    private String localizedDataSemanticVersion;

    public static final String JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION =
            "minimumRequiredLocalizedDataSemanticVersion";
    private String minimumRequiredLocalizedDataSemanticVersion;

    public static final String JSON_PROPERTY_ASSOCIATED_COMPONENT = "associatedComponent";
    private ToolComponentReference associatedComponent;

    public static final String JSON_PROPERTY_TRANSLATION_METADATA = "translationMetadata";
    private TranslationMetadata translationMetadata;

    public static final String JSON_PROPERTY_SUPPORTED_TAXONOMIES = "supportedTaxonomies";
    private Set<ToolComponentReference> supportedTaxonomies = new LinkedHashSet<>();

    public static final String JSON_PROPERTY_PROPERTIES = "properties";
    private PropertyBag properties;

    public ToolComponent() {}

    public ToolComponent guid(String guid) {
        this.guid = guid;
        return this;
    }

    /**
     * A unique identifier for the tool component in the form of a GUID.
     * @return guid
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_GUID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getGuid() {
        return guid;
    }

    @JsonProperty(JSON_PROPERTY_GUID)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setGuid(String guid) {
        this.guid = guid;
    }

    public ToolComponent name(String name) {
        this.name = name;
        return this;
    }

    /**
     * The name of the tool component.
     * @return name
     **/
    @javax.annotation.Nonnull
    @JsonProperty(JSON_PROPERTY_NAME)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)
    public String getName() {
        return name;
    }

    @JsonProperty(JSON_PROPERTY_NAME)
    @JsonInclude(value = JsonInclude.Include.ALWAYS)
    public void setName(String name) {
        this.name = name;
    }

    public ToolComponent organization(String organization) {
        this.organization = organization;
        return this;
    }

    /**
     * The organization or company that produced the tool component.
     * @return organization
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_ORGANIZATION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getOrganization() {
        return organization;
    }

    @JsonProperty(JSON_PROPERTY_ORGANIZATION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setOrganization(String organization) {
        this.organization = organization;
    }

    public ToolComponent product(String product) {
        this.product = product;
        return this;
    }

    /**
     * A product suite to which the tool component belongs.
     * @return product
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_PRODUCT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProduct() {
        return product;
    }

    @JsonProperty(JSON_PROPERTY_PRODUCT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProduct(String product) {
        this.product = product;
    }

    public ToolComponent productSuite(String productSuite) {
        this.productSuite = productSuite;
        return this;
    }

    /**
     * A localizable string containing the name of the suite of products to which the tool component belongs.
     * @return productSuite
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_PRODUCT_SUITE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getProductSuite() {
        return productSuite;
    }

    @JsonProperty(JSON_PROPERTY_PRODUCT_SUITE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProductSuite(String productSuite) {
        this.productSuite = productSuite;
    }

    public ToolComponent shortDescription(MultiformatMessageString shortDescription) {
        this.shortDescription = shortDescription;
        return this;
    }

    /**
     * Get shortDescription
     * @return shortDescription
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_SHORT_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public MultiformatMessageString getShortDescription() {
        return shortDescription;
    }

    @JsonProperty(JSON_PROPERTY_SHORT_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setShortDescription(MultiformatMessageString shortDescription) {
        this.shortDescription = shortDescription;
    }

    public ToolComponent fullDescription(MultiformatMessageString fullDescription) {
        this.fullDescription = fullDescription;
        return this;
    }

    /**
     * Get fullDescription
     * @return fullDescription
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_FULL_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public MultiformatMessageString getFullDescription() {
        return fullDescription;
    }

    @JsonProperty(JSON_PROPERTY_FULL_DESCRIPTION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFullDescription(MultiformatMessageString fullDescription) {
        this.fullDescription = fullDescription;
    }

    public ToolComponent fullName(String fullName) {
        this.fullName = fullName;
        return this;
    }

    /**
     * The name of the tool component along with its version and any other useful identifying information, such as its locale.
     * @return fullName
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_FULL_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getFullName() {
        return fullName;
    }

    @JsonProperty(JSON_PROPERTY_FULL_NAME)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public ToolComponent version(String version) {
        this.version = version;
        return this;
    }

    /**
     * The tool component version, in whatever format the component natively provides.
     * @return version
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getVersion() {
        return version;
    }

    @JsonProperty(JSON_PROPERTY_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setVersion(String version) {
        this.version = version;
    }

    public ToolComponent semanticVersion(String semanticVersion) {
        this.semanticVersion = semanticVersion;
        return this;
    }

    /**
     * The tool component version in the format specified by Semantic Versioning 2.0.
     * @return semanticVersion
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getSemanticVersion() {
        return semanticVersion;
    }

    @JsonProperty(JSON_PROPERTY_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setSemanticVersion(String semanticVersion) {
        this.semanticVersion = semanticVersion;
    }

    public ToolComponent dottedQuadFileVersion(String dottedQuadFileVersion) {
        this.dottedQuadFileVersion = dottedQuadFileVersion;
        return this;
    }

    /**
     * The binary version of the tool component&#39;s primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).
     * @return dottedQuadFileVersion
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getDottedQuadFileVersion() {
        return dottedQuadFileVersion;
    }

    @JsonProperty(JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDottedQuadFileVersion(String dottedQuadFileVersion) {
        this.dottedQuadFileVersion = dottedQuadFileVersion;
    }

    public ToolComponent releaseDateUtc(String releaseDateUtc) {
        this.releaseDateUtc = releaseDateUtc;
        return this;
    }

    /**
     * A string specifying the UTC date (and optionally, the time) of the component&#39;s release.
     * @return releaseDateUtc
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_RELEASE_DATE_UTC)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getReleaseDateUtc() {
        return releaseDateUtc;
    }

    @JsonProperty(JSON_PROPERTY_RELEASE_DATE_UTC)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setReleaseDateUtc(String releaseDateUtc) {
        this.releaseDateUtc = releaseDateUtc;
    }

    public ToolComponent downloadUri(URI downloadUri) {
        this.downloadUri = downloadUri;
        return this;
    }

    /**
     * The absolute URI from which the tool component can be downloaded.
     * @return downloadUri
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_DOWNLOAD_URI)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public URI getDownloadUri() {
        return downloadUri;
    }

    @JsonProperty(JSON_PROPERTY_DOWNLOAD_URI)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setDownloadUri(URI downloadUri) {
        this.downloadUri = downloadUri;
    }

    public ToolComponent informationUri(URI informationUri) {
        this.informationUri = informationUri;
        return this;
    }

    /**
     * The absolute URI at which information about this version of the tool component can be found.
     * @return informationUri
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_INFORMATION_URI)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public URI getInformationUri() {
        return informationUri;
    }

    @JsonProperty(JSON_PROPERTY_INFORMATION_URI)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setInformationUri(URI informationUri) {
        this.informationUri = informationUri;
    }

    public ToolComponent globalMessageStrings(Map<String, MultiformatMessageString> globalMessageStrings) {
        this.globalMessageStrings = globalMessageStrings;
        return this;
    }

    public ToolComponent putGlobalMessageStringsItem(String key, MultiformatMessageString globalMessageStringsItem) {
        if (this.globalMessageStrings == null) {
            this.globalMessageStrings = new HashMap<>();
        }
        this.globalMessageStrings.put(key, globalMessageStringsItem);
        return this;
    }

    /**
     * A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.
     * @return globalMessageStrings
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Map<String, MultiformatMessageString> getGlobalMessageStrings() {
        return globalMessageStrings;
    }

    @JsonProperty(JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setGlobalMessageStrings(Map<String, MultiformatMessageString> globalMessageStrings) {
        this.globalMessageStrings = globalMessageStrings;
    }

    public ToolComponent notifications(Set<ReportingDescriptor> notifications) {
        this.notifications = notifications;
        return this;
    }

    public ToolComponent addNotificationsItem(ReportingDescriptor notificationsItem) {
        if (this.notifications == null) {
            this.notifications = new LinkedHashSet<>();
        }
        this.notifications.add(notificationsItem);
        return this;
    }

    /**
     * An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.
     * @return notifications
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_NOTIFICATIONS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Set<ReportingDescriptor> getNotifications() {
        return notifications;
    }

    @JsonDeserialize(as = LinkedHashSet.class)
    @JsonProperty(JSON_PROPERTY_NOTIFICATIONS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setNotifications(Set<ReportingDescriptor> notifications) {
        this.notifications = notifications;
    }

    public ToolComponent rules(Set<ReportingDescriptor> rules) {
        this.rules = rules;
        return this;
    }

    public ToolComponent addRulesItem(ReportingDescriptor rulesItem) {
        if (this.rules == null) {
            this.rules = new LinkedHashSet<>();
        }
        this.rules.add(rulesItem);
        return this;
    }

    /**
     * An array of reportingDescriptor objects relevant to the analysis performed by the tool component.
     * @return rules
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_RULES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Set<ReportingDescriptor> getRules() {
        return rules;
    }

    @JsonDeserialize(as = LinkedHashSet.class)
    @JsonProperty(JSON_PROPERTY_RULES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setRules(Set<ReportingDescriptor> rules) {
        this.rules = rules;
    }

    public ToolComponent taxa(Set<ReportingDescriptor> taxa) {
        this.taxa = taxa;
        return this;
    }

    public ToolComponent addTaxaItem(ReportingDescriptor taxaItem) {
        if (this.taxa == null) {
            this.taxa = new LinkedHashSet<>();
        }
        this.taxa.add(taxaItem);
        return this;
    }

    /**
     * An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.
     * @return taxa
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_TAXA)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Set<ReportingDescriptor> getTaxa() {
        return taxa;
    }

    @JsonDeserialize(as = LinkedHashSet.class)
    @JsonProperty(JSON_PROPERTY_TAXA)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTaxa(Set<ReportingDescriptor> taxa) {
        this.taxa = taxa;
    }

    public ToolComponent locations(List<ArtifactLocation> locations) {
        this.locations = locations;
        return this;
    }

    public ToolComponent addLocationsItem(ArtifactLocation locationsItem) {
        if (this.locations == null) {
            this.locations = new ArrayList<>();
        }
        this.locations.add(locationsItem);
        return this;
    }

    /**
     * An array of the artifactLocation objects associated with the tool component.
     * @return locations
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_LOCATIONS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public List<ArtifactLocation> getLocations() {
        return locations;
    }

    @JsonProperty(JSON_PROPERTY_LOCATIONS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setLocations(List<ArtifactLocation> locations) {
        this.locations = locations;
    }

    public ToolComponent language(String language) {
        this.language = language;
        return this;
    }

    /**
     * The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).
     * @return language
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_LANGUAGE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getLanguage() {
        return language;
    }

    @JsonProperty(JSON_PROPERTY_LANGUAGE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setLanguage(String language) {
        this.language = language;
    }

    public ToolComponent contents(Set<ContentsEnum> contents) {
        this.contents = contents;
        return this;
    }

    public ToolComponent addContentsItem(ContentsEnum contentsItem) {
        if (this.contents == null) {
            this.contents =
                    new LinkedHashSet<>(Arrays.asList(ContentsEnum.LOCALIZEDDATA, ContentsEnum.NONLOCALIZEDDATA));
        }
        this.contents.add(contentsItem);
        return this;
    }

    /**
     * The kinds of data contained in this object.
     * @return contents
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_CONTENTS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Set<ContentsEnum> getContents() {
        return contents;
    }

    @JsonDeserialize(as = LinkedHashSet.class)
    @JsonProperty(JSON_PROPERTY_CONTENTS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setContents(Set<ContentsEnum> contents) {
        this.contents = contents;
    }

    public ToolComponent isComprehensive(Boolean isComprehensive) {
        this.isComprehensive = isComprehensive;
        return this;
    }

    /**
     * Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.
     * @return isComprehensive
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_IS_COMPREHENSIVE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Boolean getIsComprehensive() {
        return isComprehensive;
    }

    @JsonProperty(JSON_PROPERTY_IS_COMPREHENSIVE)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setIsComprehensive(Boolean isComprehensive) {
        this.isComprehensive = isComprehensive;
    }

    public ToolComponent localizedDataSemanticVersion(String localizedDataSemanticVersion) {
        this.localizedDataSemanticVersion = localizedDataSemanticVersion;
        return this;
    }

    /**
     * The semantic version of the localized strings defined in this component; maintained by components that provide translations.
     * @return localizedDataSemanticVersion
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getLocalizedDataSemanticVersion() {
        return localizedDataSemanticVersion;
    }

    @JsonProperty(JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setLocalizedDataSemanticVersion(String localizedDataSemanticVersion) {
        this.localizedDataSemanticVersion = localizedDataSemanticVersion;
    }

    public ToolComponent minimumRequiredLocalizedDataSemanticVersion(
            String minimumRequiredLocalizedDataSemanticVersion) {
        this.minimumRequiredLocalizedDataSemanticVersion = minimumRequiredLocalizedDataSemanticVersion;
        return this;
    }

    /**
     * The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.
     * @return minimumRequiredLocalizedDataSemanticVersion
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getMinimumRequiredLocalizedDataSemanticVersion() {
        return minimumRequiredLocalizedDataSemanticVersion;
    }

    @JsonProperty(JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setMinimumRequiredLocalizedDataSemanticVersion(String minimumRequiredLocalizedDataSemanticVersion) {
        this.minimumRequiredLocalizedDataSemanticVersion = minimumRequiredLocalizedDataSemanticVersion;
    }

    public ToolComponent associatedComponent(ToolComponentReference associatedComponent) {
        this.associatedComponent = associatedComponent;
        return this;
    }

    /**
     * Get associatedComponent
     * @return associatedComponent
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_ASSOCIATED_COMPONENT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public ToolComponentReference getAssociatedComponent() {
        return associatedComponent;
    }

    @JsonProperty(JSON_PROPERTY_ASSOCIATED_COMPONENT)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setAssociatedComponent(ToolComponentReference associatedComponent) {
        this.associatedComponent = associatedComponent;
    }

    public ToolComponent translationMetadata(TranslationMetadata translationMetadata) {
        this.translationMetadata = translationMetadata;
        return this;
    }

    /**
     * Get translationMetadata
     * @return translationMetadata
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_TRANSLATION_METADATA)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public TranslationMetadata getTranslationMetadata() {
        return translationMetadata;
    }

    @JsonProperty(JSON_PROPERTY_TRANSLATION_METADATA)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setTranslationMetadata(TranslationMetadata translationMetadata) {
        this.translationMetadata = translationMetadata;
    }

    public ToolComponent supportedTaxonomies(Set<ToolComponentReference> supportedTaxonomies) {
        this.supportedTaxonomies = supportedTaxonomies;
        return this;
    }

    public ToolComponent addSupportedTaxonomiesItem(ToolComponentReference supportedTaxonomiesItem) {
        if (this.supportedTaxonomies == null) {
            this.supportedTaxonomies = new LinkedHashSet<>();
        }
        this.supportedTaxonomies.add(supportedTaxonomiesItem);
        return this;
    }

    /**
     * An array of toolComponentReference objects to declare the taxonomies supported by the tool component.
     * @return supportedTaxonomies
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_SUPPORTED_TAXONOMIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Set<ToolComponentReference> getSupportedTaxonomies() {
        return supportedTaxonomies;
    }

    @JsonDeserialize(as = LinkedHashSet.class)
    @JsonProperty(JSON_PROPERTY_SUPPORTED_TAXONOMIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setSupportedTaxonomies(Set<ToolComponentReference> supportedTaxonomies) {
        this.supportedTaxonomies = supportedTaxonomies;
    }

    public ToolComponent properties(PropertyBag properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get properties
     * @return properties
     **/
    @javax.annotation.Nullable
    @JsonProperty(JSON_PROPERTY_PROPERTIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public PropertyBag getProperties() {
        return properties;
    }

    @JsonProperty(JSON_PROPERTY_PROPERTIES)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public void setProperties(PropertyBag properties) {
        this.properties = properties;
    }

    /**
     * Return true if this toolComponent object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ToolComponent toolComponent = (ToolComponent) o;
        return Objects.equals(this.guid, toolComponent.guid)
                && Objects.equals(this.name, toolComponent.name)
                && Objects.equals(this.organization, toolComponent.organization)
                && Objects.equals(this.product, toolComponent.product)
                && Objects.equals(this.productSuite, toolComponent.productSuite)
                && Objects.equals(this.shortDescription, toolComponent.shortDescription)
                && Objects.equals(this.fullDescription, toolComponent.fullDescription)
                && Objects.equals(this.fullName, toolComponent.fullName)
                && Objects.equals(this.version, toolComponent.version)
                && Objects.equals(this.semanticVersion, toolComponent.semanticVersion)
                && Objects.equals(this.dottedQuadFileVersion, toolComponent.dottedQuadFileVersion)
                && Objects.equals(this.releaseDateUtc, toolComponent.releaseDateUtc)
                && Objects.equals(this.downloadUri, toolComponent.downloadUri)
                && Objects.equals(this.informationUri, toolComponent.informationUri)
                && Objects.equals(this.globalMessageStrings, toolComponent.globalMessageStrings)
                && Objects.equals(this.notifications, toolComponent.notifications)
                && Objects.equals(this.rules, toolComponent.rules)
                && Objects.equals(this.taxa, toolComponent.taxa)
                && Objects.equals(this.locations, toolComponent.locations)
                && Objects.equals(this.language, toolComponent.language)
                && Objects.equals(this.contents, toolComponent.contents)
                && Objects.equals(this.isComprehensive, toolComponent.isComprehensive)
                && Objects.equals(this.localizedDataSemanticVersion, toolComponent.localizedDataSemanticVersion)
                && Objects.equals(
                        this.minimumRequiredLocalizedDataSemanticVersion,
                        toolComponent.minimumRequiredLocalizedDataSemanticVersion)
                && Objects.equals(this.associatedComponent, toolComponent.associatedComponent)
                && Objects.equals(this.translationMetadata, toolComponent.translationMetadata)
                && Objects.equals(this.supportedTaxonomies, toolComponent.supportedTaxonomies)
                && Objects.equals(this.properties, toolComponent.properties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
                guid,
                name,
                organization,
                product,
                productSuite,
                shortDescription,
                fullDescription,
                fullName,
                version,
                semanticVersion,
                dottedQuadFileVersion,
                releaseDateUtc,
                downloadUri,
                informationUri,
                globalMessageStrings,
                notifications,
                rules,
                taxa,
                locations,
                language,
                contents,
                isComprehensive,
                localizedDataSemanticVersion,
                minimumRequiredLocalizedDataSemanticVersion,
                associatedComponent,
                translationMetadata,
                supportedTaxonomies,
                properties);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class ToolComponent {\n");
        sb.append("    guid: ").append(toIndentedString(guid)).append("\n");
        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    organization: ").append(toIndentedString(organization)).append("\n");
        sb.append("    product: ").append(toIndentedString(product)).append("\n");
        sb.append("    productSuite: ").append(toIndentedString(productSuite)).append("\n");
        sb.append("    shortDescription: ")
                .append(toIndentedString(shortDescription))
                .append("\n");
        sb.append("    fullDescription: ")
                .append(toIndentedString(fullDescription))
                .append("\n");
        sb.append("    fullName: ").append(toIndentedString(fullName)).append("\n");
        sb.append("    version: ").append(toIndentedString(version)).append("\n");
        sb.append("    semanticVersion: ")
                .append(toIndentedString(semanticVersion))
                .append("\n");
        sb.append("    dottedQuadFileVersion: ")
                .append(toIndentedString(dottedQuadFileVersion))
                .append("\n");
        sb.append("    releaseDateUtc: ")
                .append(toIndentedString(releaseDateUtc))
                .append("\n");
        sb.append("    downloadUri: ").append(toIndentedString(downloadUri)).append("\n");
        sb.append("    informationUri: ")
                .append(toIndentedString(informationUri))
                .append("\n");
        sb.append("    globalMessageStrings: ")
                .append(toIndentedString(globalMessageStrings))
                .append("\n");
        sb.append("    notifications: ").append(toIndentedString(notifications)).append("\n");
        sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
        sb.append("    taxa: ").append(toIndentedString(taxa)).append("\n");
        sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
        sb.append("    language: ").append(toIndentedString(language)).append("\n");
        sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
        sb.append("    isComprehensive: ")
                .append(toIndentedString(isComprehensive))
                .append("\n");
        sb.append("    localizedDataSemanticVersion: ")
                .append(toIndentedString(localizedDataSemanticVersion))
                .append("\n");
        sb.append("    minimumRequiredLocalizedDataSemanticVersion: ")
                .append(toIndentedString(minimumRequiredLocalizedDataSemanticVersion))
                .append("\n");
        sb.append("    associatedComponent: ")
                .append(toIndentedString(associatedComponent))
                .append("\n");
        sb.append("    translationMetadata: ")
                .append(toIndentedString(translationMetadata))
                .append("\n");
        sb.append("    supportedTaxonomies: ")
                .append(toIndentedString(supportedTaxonomies))
                .append("\n");
        sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

    /**
     * Convert the instance into URL query string.
     *
     * @return URL query string
     */
    public String toUrlQueryString() {
        return toUrlQueryString(null);
    }

    /**
     * Convert the instance into URL query string.
     *
     * @param prefix prefix of the query string
     * @return URL query string
     */
    public String toUrlQueryString(String prefix) {
        String suffix = "";
        String containerSuffix = "";
        String containerPrefix = "";
        if (prefix == null) {
            // style=form, explode=true, e.g. /pet?name=cat&type=manx
            prefix = "";
        } else {
            // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
            prefix = prefix + "[";
            suffix = "]";
            containerSuffix = "]";
            containerPrefix = "[";
        }

        StringJoiner joiner = new StringJoiner("&");

        // add `guid` to the URL query string
        if (getGuid() != null) {
            joiner.add(String.format(
                    "%sguid%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getGuid()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `name` to the URL query string
        if (getName() != null) {
            joiner.add(String.format(
                    "%sname%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getName()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `organization` to the URL query string
        if (getOrganization() != null) {
            joiner.add(String.format(
                    "%sorganization%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getOrganization()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `product` to the URL query string
        if (getProduct() != null) {
            joiner.add(String.format(
                    "%sproduct%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getProduct()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `productSuite` to the URL query string
        if (getProductSuite() != null) {
            joiner.add(String.format(
                    "%sproductSuite%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getProductSuite()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `shortDescription` to the URL query string
        if (getShortDescription() != null) {
            joiner.add(getShortDescription().toUrlQueryString(prefix + "shortDescription" + suffix));
        }

        // add `fullDescription` to the URL query string
        if (getFullDescription() != null) {
            joiner.add(getFullDescription().toUrlQueryString(prefix + "fullDescription" + suffix));
        }

        // add `fullName` to the URL query string
        if (getFullName() != null) {
            joiner.add(String.format(
                    "%sfullName%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getFullName()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `version` to the URL query string
        if (getVersion() != null) {
            joiner.add(String.format(
                    "%sversion%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getVersion()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `semanticVersion` to the URL query string
        if (getSemanticVersion() != null) {
            joiner.add(String.format(
                    "%ssemanticVersion%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getSemanticVersion()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `dottedQuadFileVersion` to the URL query string
        if (getDottedQuadFileVersion() != null) {
            joiner.add(String.format(
                    "%sdottedQuadFileVersion%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getDottedQuadFileVersion()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `releaseDateUtc` to the URL query string
        if (getReleaseDateUtc() != null) {
            joiner.add(String.format(
                    "%sreleaseDateUtc%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getReleaseDateUtc()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `downloadUri` to the URL query string
        if (getDownloadUri() != null) {
            joiner.add(String.format(
                    "%sdownloadUri%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getDownloadUri()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `informationUri` to the URL query string
        if (getInformationUri() != null) {
            joiner.add(String.format(
                    "%sinformationUri%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getInformationUri()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `globalMessageStrings` to the URL query string
        if (getGlobalMessageStrings() != null) {
            for (String _key : getGlobalMessageStrings().keySet()) {
                if (getGlobalMessageStrings().get(_key) != null) {
                    joiner.add(getGlobalMessageStrings()
                            .get(_key)
                            .toUrlQueryString(String.format(
                                    "%sglobalMessageStrings%s%s",
                                    prefix,
                                    suffix,
                                    "".equals(suffix)
                                            ? ""
                                            : String.format("%s%d%s", containerPrefix, _key, containerSuffix))));
                }
            }
        }

        // add `notifications` to the URL query string
        if (getNotifications() != null) {
            int i = 0;
            for (ReportingDescriptor _item : getNotifications()) {
                if (_item != null) {
                    joiner.add(_item.toUrlQueryString(String.format(
                            "%snotifications%s%s",
                            prefix,
                            suffix,
                            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
                }
            }
            i++;
        }

        // add `rules` to the URL query string
        if (getRules() != null) {
            int i = 0;
            for (ReportingDescriptor _item : getRules()) {
                if (_item != null) {
                    joiner.add(_item.toUrlQueryString(String.format(
                            "%srules%s%s",
                            prefix,
                            suffix,
                            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
                }
            }
            i++;
        }

        // add `taxa` to the URL query string
        if (getTaxa() != null) {
            int i = 0;
            for (ReportingDescriptor _item : getTaxa()) {
                if (_item != null) {
                    joiner.add(_item.toUrlQueryString(String.format(
                            "%staxa%s%s",
                            prefix,
                            suffix,
                            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
                }
            }
            i++;
        }

        // add `locations` to the URL query string
        if (getLocations() != null) {
            for (int i = 0; i < getLocations().size(); i++) {
                if (getLocations().get(i) != null) {
                    joiner.add(getLocations()
                            .get(i)
                            .toUrlQueryString(String.format(
                                    "%slocations%s%s",
                                    prefix,
                                    suffix,
                                    "".equals(suffix)
                                            ? ""
                                            : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
                }
            }
        }

        // add `language` to the URL query string
        if (getLanguage() != null) {
            joiner.add(String.format(
                    "%slanguage%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getLanguage()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `contents` to the URL query string
        if (getContents() != null) {
            int i = 0;
            for (ContentsEnum _item : getContents()) {
                joiner.add(String.format(
                        "%scontents%s%s=%s",
                        prefix,
                        suffix,
                        "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
                        URLEncoder.encode(String.valueOf(_item), StandardCharsets.UTF_8)
                                .replaceAll("\\+", "%20")));
            }
            i++;
        }

        // add `isComprehensive` to the URL query string
        if (getIsComprehensive() != null) {
            joiner.add(String.format(
                    "%sisComprehensive%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getIsComprehensive()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `localizedDataSemanticVersion` to the URL query string
        if (getLocalizedDataSemanticVersion() != null) {
            joiner.add(String.format(
                    "%slocalizedDataSemanticVersion%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getLocalizedDataSemanticVersion()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `minimumRequiredLocalizedDataSemanticVersion` to the URL query string
        if (getMinimumRequiredLocalizedDataSemanticVersion() != null) {
            joiner.add(String.format(
                    "%sminimumRequiredLocalizedDataSemanticVersion%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(
                                    String.valueOf(getMinimumRequiredLocalizedDataSemanticVersion()),
                                    StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        // add `associatedComponent` to the URL query string
        if (getAssociatedComponent() != null) {
            joiner.add(getAssociatedComponent().toUrlQueryString(prefix + "associatedComponent" + suffix));
        }

        // add `translationMetadata` to the URL query string
        if (getTranslationMetadata() != null) {
            joiner.add(getTranslationMetadata().toUrlQueryString(prefix + "translationMetadata" + suffix));
        }

        // add `supportedTaxonomies` to the URL query string
        if (getSupportedTaxonomies() != null) {
            int i = 0;
            for (ToolComponentReference _item : getSupportedTaxonomies()) {
                if (_item != null) {
                    joiner.add(_item.toUrlQueryString(String.format(
                            "%ssupportedTaxonomies%s%s",
                            prefix,
                            suffix,
                            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
                }
            }
            i++;
        }

        // add `properties` to the URL query string
        if (getProperties() != null) {
            joiner.add(String.format(
                    "%sproperties%s=%s",
                    prefix,
                    suffix,
                    URLEncoder.encode(String.valueOf(getProperties()), StandardCharsets.UTF_8)
                            .replaceAll("\\+", "%20")));
        }

        return joiner.toString();
    }
}
